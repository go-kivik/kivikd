package kivik

import (
	"context"
	"strings"

	"github.com/flimzy/kivik/driver"
	"github.com/flimzy/kivik/errors"
)

// Rows is an iterator over a a multi-value query.
type Rows struct {
	*iter
	rowsi driver.Rows
}

// Next prepares the next result value for reading. It returns true on success
// or false if there are no more results or an error  occurs while preparing it.
// Err should be consulted to distinguish between the two.
func (r *Rows) Next() bool {
	return r.iter.Next()
}

// Err returns the error, if any, that was encountered during iteration. Err may
// be called after an explicit or implicit Close.
func (r *Rows) Err() error {
	return r.iter.Err()
}

// Close closes the Rows, preventing further enumeration, and freeing any
// resources (such as the http request body) of the underlying query. If Next is
// called and there are no further results, Rows is closed automatically and it
// will suffice to check the result of Err. Close is idempotent and does not
// affect the result of Err.
func (r *Rows) Close() error {
	return r.iter.Close()
}

type rowsIterator struct{ driver.Rows }

var _ iterator = &rowsIterator{}

func (r *rowsIterator) Next(i interface{}) error { return r.Rows.Next(i.(*driver.Row)) }

func newRows(ctx context.Context, rowsi driver.Rows) *Rows {
	return &Rows{
		iter:  newIterator(ctx, &rowsIterator{rowsi}, &driver.Row{}),
		rowsi: rowsi,
	}
}

var errNilPtr = errors.New("kivik: destination pointer is nil")

// ScanValue copies the data from the result value into the value pointed at by
// dest. Think of this as a json.Unmarshal into dest.
//
// If the dest argument has type *[]byte, Scan stores a copy of the input data.
// The copy is owned by the caller and can be modified and held indefinitely.
//
// The copy can be avoided by using an argument of type *json.RawMessage
// instead. After a Scaninto a json.RawMessage, the slice is only valid until
// the next call to Next, Scan, or Close.
//
// For all other types, refer to the documentation for json.Unmarshal for type
// conversion rules.
func (r *Rows) ScanValue(dest interface{}) error {
	runlock, err := r.rlock()
	if err != nil {
		return err
	}
	defer runlock()
	return scan(dest, r.curVal.(*driver.Row).Value)
}

// ScanDoc works the same as ScanValue, but on the doc field of the result. It
// is only valid for results that include documents.
func (r *Rows) ScanDoc(dest interface{}) error {
	runlock, err := r.rlock()
	if err != nil {
		return err
	}
	defer runlock()
	doc := r.curVal.(*driver.Row).Doc
	if doc == nil {
		return errors.Status(StatusBadRequest, "kivik: doc is nil; does the query include docs?")
	}
	return scan(dest, doc)
}

// ScanKey works the same as ScanValue, but on the key field of the result. For
// simple keys, which are just strings, the Key() method may be easier to use.
func (r *Rows) ScanKey(dest interface{}) error {
	runlock, err := r.rlock()
	if err != nil {
		return err
	}
	defer runlock()
	return scan(dest, r.curVal.(*driver.Row).Key)
}

// ID returns the ID of the current result.
func (r *Rows) ID() string {
	runlock, err := r.rlock()
	if err != nil {
		return ""
	}
	defer runlock()
	return r.curVal.(*driver.Row).ID
}

// Key returns the Key of the current result as a de-quoted JSON object. For
// compound keys, the ScanKey() method may be more convenient.
func (r *Rows) Key() string {
	runlock, err := r.rlock()
	if err != nil {
		return ""
	}
	defer runlock()
	return strings.Trim(string(r.curVal.(*driver.Row).Key), `"`)
}

// Offset returns the starting offset where the result set started. It is
// only guaranteed to be set after all result rows have been enumerated through
// by Next, and thus should only be read after processing all rows in a result
// set. Calling Close before enumerating will render this value unreliable.
func (r *Rows) Offset() int64 {
	return r.rowsi.Offset()
}

// TotalRows returns the total number of rows in the view which would have been
// returned if no limiting were used. This value is only guaranteed to be set
// after all result rows have been enumerated through by Next, and thus should
// only be read after processing all rows in a result set. Calling Close before
// enumerating will render this value unreliable.
func (r *Rows) TotalRows() int64 {
	return r.rowsi.TotalRows()
}

// UpdateSeq returns the sequence id of the underlying database the view
// reflects, if requested in the query.
func (r *Rows) UpdateSeq() string {
	return r.rowsi.UpdateSeq()
}

// Warning returns a warning generated by the query, if any. This value is only
// guaranteed to be set after all result rows have been enumeratd through by
// Next.
func (r *Rows) Warning() string {
	if w, ok := r.rowsi.(driver.RowsWarner); ok {
		return w.Warning()
	}
	return ""
}
